$date
	Mon Jun 30 19:30:36 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module key_schedule_test $end
$var wire 56 ! t_r [55:0] $end
$var wire 48 " t_k [47:0] $end
$var reg 4 # t_i [3:0] $end
$var reg 56 $ t_x [55:0] $end
$scope module t $end
$var wire 4 % i [3:0] $end
$var wire 56 & x [55:0] $end
$var wire 28 ' r3 [27:0] $end
$var wire 28 ( r2 [27:0] $end
$var wire 28 ) r1 [27:0] $end
$var wire 28 * r0 [27:0] $end
$var wire 56 + r [55:0] $end
$var wire 48 , k [47:0] $end
$scope module clr1 $end
$var wire 28 - r [27:0] $end
$var wire 4 . y [3:0] $end
$var wire 28 / x [27:0] $end
$var wire 2 0 shiftVal [1:0] $end
$var wire 28 1 rightShift [27:0] $end
$var wire 28 2 leftShift [27:0] $end
$scope module s $end
$var wire 1 3 isCase $end
$var wire 1 4 w0 $end
$var wire 1 5 w1 $end
$var wire 1 6 w2 $end
$var wire 4 7 y [3:0] $end
$var wire 16 8 zoef [15:0] $end
$var wire 2 9 res [1:0] $end
$var wire 16 : mask [15:0] $end
$var wire 4 ; cnc [3:0] $end
$upscope $end
$upscope $end
$scope module clr2 $end
$var wire 28 < r [27:0] $end
$var wire 4 = y [3:0] $end
$var wire 28 > x [27:0] $end
$var wire 2 ? shiftVal [1:0] $end
$var wire 28 @ rightShift [27:0] $end
$var wire 28 A leftShift [27:0] $end
$scope module s $end
$var wire 1 B isCase $end
$var wire 1 C w0 $end
$var wire 1 D w1 $end
$var wire 1 E w2 $end
$var wire 4 F y [3:0] $end
$var wire 16 G zoef [15:0] $end
$var wire 2 H res [1:0] $end
$var wire 16 I mask [15:0] $end
$var wire 4 J cnc [3:0] $end
$upscope $end
$upscope $end
$scope module mer $end
$var wire 28 K x0 [27:0] $end
$var wire 28 L x1 [27:0] $end
$var wire 56 M r [55:0] $end
$upscope $end
$scope module per $end
$var wire 56 N x [55:0] $end
$var wire 48 O r [47:0] $end
$upscope $end
$scope module sp1 $end
$var wire 56 P x [55:0] $end
$var wire 28 Q r1 [27:0] $end
$var wire 28 R r0 [27:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b101010100110011000011111111 R
b111100110011010101011111 Q
b1111001100110101010111110101010100110011000011111111 P
b111101001111110110011000011001001011011001011010 O
b11110011001101010101111101010101001100110000111111110 N
b11110011001101010101111101010101001100110000111111110 M
b1111001100110101010111110 L
b1010101001100110000111111110 K
b1000 J
b110001111 I
b1 H
b110001111 G
b0 F
0E
1D
0C
1B
b1010101001100110000111111110 A
b0 @
b1 ?
b101010100110011000011111111 >
b0 =
b1010101001100110000111111110 <
b1000 ;
b110001111 :
b1 9
b110001111 8
b0 7
06
15
04
13
b1111001100110101010111110 2
b0 1
b1 0
b111100110011010101011111 /
b0 .
b1111001100110101010111110 -
b111101001111110110011000011001001011011001011010 ,
b11110011001101010101111101010101001100110000111111110 +
b101010100110011000011111111 *
b111100110011010101011111 )
b1111001100110101010111110 (
b1010101001100110000111111110 '
b1111001100110101010111110101010100110011000011111111 &
b0 %
b1111001100110101010111110101010100110011000011111111 $
b0 #
b111101001111110110011000011001001011011001011010 "
b11110011001101010101111101010101001100110000111111110 !
$end
#20
$dumpoff
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
xE
xD
xC
xB
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
x6
x5
x4
x3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
bx +
bx *
bx )
bx (
bx '
bx &
bx %
bx $
bx #
bx "
bx !
$end
